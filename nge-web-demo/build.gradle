
plugins {
    id "java"
    id "war"
    id "org.teavm" version "${teaVmVersion}"
}

import java.security.MessageDigest
import java.nio.file.Files
import java.nio.file.Paths
apply from: 'class-finder.gradle'

configurations {
    withResources {
        canBeResolved = true
    }
}
 
 

dependencies {
    implementation "org.teavm:teavm-jso:${teaVmVersion}"
    implementation "org.teavm:teavm-jso-apis:${teaVmVersion}"
    implementation "org.teavm:teavm-metaprogramming-api:${teaVmVersion}"
    implementation "org.teavm:teavm-classlib:${teaVmVersion}"
    implementation "org.teavm:teavm-tooling:${teaVmVersion}"
    implementation "org.teavm:teavm-core:${teaVmVersion}"
    
    implementation project(':nge-web')
    implementation project(':nge-web-bullet')
    implementation project(':nge-app')
    implementation project(':nge-auth')
    implementation project(':nge-core')
    implementation project(':nge-gui')
    implementation project(':jme3-core')
    implementation project(':jme3-testdata')
    implementation project(':jme3-effects')
    implementation project(':jme3-terrain')
    implementation project(':jme3-testdata')
    implementation project(':jme3-jogg')

    implementation( project(':jme3-plugins')){
        exclude group: 'com.google.code.gson', module: 'gson'
        exclude module: 'jme3-plugins-json-gson'

    }
    implementation project(':jme3-plugins-json')
   

    withResources project(':nge-web')
    withResources project(':nge-app')
    withResources project(':nge-auth')
    withResources project(':nge-core')
    withResources project(':nge-gui')
    withResources project(':jme3-core')
    withResources project(':jme3-testdata')
    withResources project(':jme3-effects')
    withResources project(':jme3-terrain')
    withResources project(':jme3-testdata')
    withResources project(':jme3-jogg')
    withResources project(':jme3-plugins')
 
}



java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

sourceSets {
    test {
        resources {
            srcDirs = ['src/test/resources', 'src/main/resources']            
        }
    }
}

def binaryExclusions = [
    '**/*.class',
    '**/*.dll',
    '**/*.so',
    '**/*.dylib',
    '**/package.html',
    "**/*.kotlin_builtins",
    "**/build.data",
]
task copyAllResources {
    description = "Copy all resources to the TeaVM output directory"
    group = "build"
    
    dependsOn configurations.withResources.getAllDependencies().withType(ProjectDependency).collect { 
        "${it.dependencyProject.path}:jar"
    }

    dependsOn 'compileTeavmJava', 'compileTeavmGroovy', 'processTeavmResources'

    doFirst {
        delete "$buildDir/generated/teavm/js"
    }

    doLast {
        def dest = file("$buildDir/generated/teavm/js")
        dest.mkdirs()

        // helper to perform a copy with binary exclusions
        def safeCopy = { spec ->
            copy {
                into dest
                from spec
                exclude(*binaryExclusions)
                duplicatesStrategy = DuplicatesStrategy.INCLUDE
                includeEmptyDirs = false  // Don't include empty directories
            }
        }

        safeCopy('src/main/resources')

        configurations.withResources.getAllDependencies().withType(ProjectDependency).each { pd ->
            def jarTask = pd.dependencyProject.tasks.findByName('jar')
            if (jarTask != null) {
                def jarFile = jarTask.archiveFile.get().asFile
                if (jarFile.exists()) {
                    safeCopy(project.zipTree(jarFile))
                } else {
                    safeCopy(pd.dependencyProject.sourceSets.main.output)
                }
            }
        }
    }
}
task generateResourcesIndex {
    dependsOn copyAllResources

    doLast {
        def outputDir = file("$buildDir/generated/teavm/js/")
        def outputFile = file("$buildDir/generated/teavm/js/resourcesIndex.txt")

        outputFile.text = generateHashes(outputDir)
    }
}

def generateHashes(File dir) {
    def hashes = []
    Files.walk(Paths.get(dir.toURI())).filter { 
        Files.isRegularFile(it) 
    }.forEach { file ->
        def relativePath = dir.toPath().relativize(file).toString()
        if(relativePath.endsWith(".class")) return;
        if(relativePath.endsWith(".java")) return;
        def hash = generateSHA256(file.toFile())
        hashes << "$hash $relativePath"
    }
    return hashes.join('\n')
}

def generateSHA256(file) {
    def messageDigest = MessageDigest.getInstance("SHA-256")
    file.eachByte(4096) { bytes, len ->
        messageDigest.update(bytes, 0, len)
    }
    return messageDigest.digest().collect { String.format("%02x", it) }.join()
}


task buildWebApp {
    group = 'web'
    description = 'Compile, generate JS, copy resources and produce resources index.'
    dependsOn 'compileJava',  'generateJavaScript', 'copyAllResources', 'generateResourcesIndex'
 
}

task runWebApp(type: Exec) {
    group = 'web'
    description = "Runs a simple HTTP server serving $buildDir/generated/teavm/js (port 8000)."

    dependsOn buildWebApp

    workingDir = file("$buildDir/generated/teavm/js")

    commandLine = ['python3', '-m', 'http.server', '8000']
    standardInput = System.in
}

task scanClasspathForTeaVM {
    description = "Scans classpath for classes for TeaVM preservation and reflection"
    group = "build"

    // Ensure jars of all project deps (including transitive) are built
    dependsOn configurations.runtimeClasspath.getTaskDependencyFromProjectDependency(true, "jar")
    dependsOn "jar"

    doLast {
        // Build classpath from resolved artifacts (transitive) in lenient mode
        def runtimeArtifacts = configurations.runtimeClasspath.incoming.artifactView {
            lenient true
        }.artifacts.artifactFiles

        // Optionally merge compile artifacts as a fallback
        def compileArtifacts = configurations.compileClasspath.incoming.artifactView {
            lenient true
        }.artifacts.artifactFiles

        Set<File> classpath = new LinkedHashSet<>()
        // This projectâ€™s compiled classes (dirs)
        classpath.addAll(sourceSets.main.output.files)
        // All resolved artifacts (transitive), jars/dirs
        classpath.addAll(runtimeArtifacts.files)
        classpath.addAll(compileArtifacts.files)

        // Keep only existing dirs/jars
        classpath = classpath.findAll { it.exists() && (it.isDirectory() || it.name.endsWith(".jar")) } as Set<File>

        println "Scanning ${classpath.size()} classpath entries"

        def scanResults = project.scanClasspathForClasses(classpath)

        def preserveListFile = file("${buildDir}/generated/teaReflectList.txt")
        project.generateClassListFile(preserveListFile, scanResults.classes) { className ->
            "**/${className.replace('.', '/')}.java"
        }

        def reflectionSupplierFile = file("${buildDir}/generated/teaReflect.java")
        def template = """private static void initGenerated() {
{{classInitializers}}
    }"""
        project.generateCodeFromTemplate(reflectionSupplierFile, template, [
            classInitializers: scanResults.reflectionClasses.collect {
                "        TeaReflectionSupplier.addReflectionClass(\"${it}\");"
            }.join('\n')
        ])
    }
}

task updateTeaReflectionSupplier {
    description = "Updates the TeaReflectionSupplier.java file with generated initGenerated method"
    group = "build"
    dependsOn scanClasspathForTeaVM
    
    doLast {
        def reflectionSupplierFile = file("${buildDir}/generated/teaReflect.java")
        def teaReflectionSupplierFile = file("${projectDir}/src/main/java/org/ngengine/platform/TeaReflectionSupplier.java")
        
        if (reflectionSupplierFile.exists() && teaReflectionSupplierFile.exists()) {
            def content = teaReflectionSupplierFile.text
            def initGeneratedContent = reflectionSupplierFile.text
            content = content.replaceAll(/(?s)private static void initGenerated\(\)\s*\{.*?\}/, initGeneratedContent)
            teaReflectionSupplierFile.text = content
            println "Updated TeaReflectionSupplier.java with generated initGenerated() method"
        }
    }
}

compileTeavmJava.dependsOn updateTeaReflectionSupplier

teavm.js {
    addedToWebApp = false
    mainClass = "org.ngengine.web.WebApp"
    obfuscated = false
    debugInformation = true
    strict= false
    outOfProcess=false
    // processMemory=6000
    // fastGlobalAnalysis=false
    optimization=org.teavm.gradle.api.OptimizationLevel.NONE
    sourceMap=true
    
    moduleType = org.teavm.gradle.api.JSModuleType.ES2015  

    properties = [
        "teavm.c.vmAssertions": "false"
    ]
    
    def preserveListFile = file("${buildDir}/generated/teaReflectList.txt")
    if (preserveListFile.exists()) {
        preserveListFile.readLines().each { line ->
            if (line.trim()) {
                preservedClasses.add(line.trim())
            }
        }
    }

    targetFileName = "webapp.js"
}

